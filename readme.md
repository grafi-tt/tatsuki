# リバーシエンジンTatsuki
author: grafi

Haskellで実装したリバーシエンジン．

TODO コンパイルは通ったが，未テスト（これからやる）
TODO 課題提出用の考察とreadmeは分けたほうがいいね

## 技術的概要
### 第一目標（達成）
-   ビットボードを用いてビット演算を多用した盤面処理
    -   ビットボードの場合当然な気はするが，盤面は都度コピーする実装
    -   **特に，着手した後の盤面更新処理では，既知では無さそうな方法を用いている（後述）**
-   αβ法
-   古典的評価関数
    -   着手可能数，角の数，駒差を用いる
-   浅い読みの結果を用いたMove Ordering

### いつかやりたい
評価関数を先に改良しないと、評価関数の重さが全然変わるので枝狩り数の改良の効果がよく分からない気がする。

-   パターンに対する評価関数を機械学習によって作る
-   NegaScout（これは楽だし評価関数の前にやるかも）
-   置換表
-   ProbCut

### やる気は無い
-   定石

## 盤面更新処理
レポート提出までには書く

## 着手の列挙
wZebraと同じ
http://d.hatena.ne.jp/ainame/20100426/1272236395 も参照

## 探索方法についての考察
-   今回の実装は単なる手抜き
-   置換表がどこで役立つか
    -   余分な探索を端折る
    -   正確なMove-Ordering
        -   本来Move-Orderingのための評価関数で得られる以上の精度
            -   深さによる精度向上
            -   枝狩りされていないため良い手が残る
            -   移動した後の盤面が置換表に入っている場合も良いが，移動前の盤面が置換表に入っていてその盤面からの最善手が移動後の盤面であると確定している場合はさらに良い
                -   ただし，枝狩りがあるので最善手が読まれるノードは多くは無さそう
                -   具体的な手を置換表に入れるかどうかという問題（最善手だけならたかだか1byteなので悪くはないのかも？）
-   置換に探索の深さをいれる際
    -   vsOtha，ThelloなどのIS2004勢では反復深化+二枚の置換表という実装で，深さは入っていない（ような気はするが自信無い）
    -   深ければ方が精度が良い，というやり方で更新
        -   オセロだと，何も考えずに評価関数を作ると，局面の進行具合に応じて評価関数の値の平均が変わることが起こりかねない，この場合異なる深さの読みを比較できない
            -   オセロは単調に駒の総和が増える方向に局面が変化していくという特徴があるかあ，異なる深さの読みを比較しないという前提で，こんな実装が許されるが，将棋とかを考えると許されない
            -   他，終局の処理が若干手抜き，あと千日手は当然なかったり（もうちょっと整理して書く）

## 名前の由来
-   ゲーム木という木構造を探索するプログラムである「樹」
-   リバーシの盤面が満月と新月に例えられることから「多月」
